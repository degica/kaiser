#!/usr/bin/env ruby

require 'optimist'
require 'fileutils'
require 'yaml'
require 'json'
require 'pty'
require 'erb'

require 'kaiser'

main_usage <<EOS
Kaiser is a tool to make development a lot easier by defining how an application starts using a `Kaiserfile` in the source code's root directory.

### Prerequisites

Install docker on your system and make sure the current user have all the rights required to spin up docker containers.

### Usage

For typical usuage you'll want to do the following three commands.

```
kaiser init ENV_NAME
kaiser up
kaiser attach
```

This will boot up your application in docker and bind mount your local source directory so you can start doing development. Happy coding!

If any of these commands are giving you trouble, please run them with the `-v` flag set. They will show you what exactly is happening so you can debug.
EOS

init_usage <<EOS
Initializes a Kaiser environment and assigns ports for it in `~/.kaiser/.config.yml`. When running `kaiser up` later the directory `~/.kaiser/databases/<ENV_NAME>`  will get created.

Usage: kaiser init ENV_NAME
EOS

deinit_usage <<EOS
Removes the Kaiser environment from `~/.kaiser/.config.yml`. This however does not delete the `~/.kaiser/databases/<ENV_NAME>` directory.

Usage: kaiser init ENV_NAME
EOS

up_usage <<EOS
Boots up the application in docker as defined in the `Kaiserfile` in its source code. Usually this will create two docker containers `<ENV_NAME>-db` and `<ENV_NAME>-app` running your database and application respectively.

A backup of the default database is created and saved to `~/.kaiser/<ENV_NAME>/<current_github_branch_name>/.default.tar.bz`. This can be restored at any time using the `db_reset` command.

Usage: kaiser up
EOS

down_usage <<EOS
Shuts down and *deletes* the containers that were started using `kaiser up`.

Usage: kaiser down
EOS

db_save_usage <<EOS
Shuts down the database docker container, backs up the database and brings the container back up.

The database will be saved as a tarball to `~/.kaiser/<ENV_NAME>/<current_github_branch_name>/<DB_BACKUP_FILENAME>.tar.bz`

Alternatively you can also save it to your current directory.

Usage: kaiser db_save DB_BACKUP_FILENAME
       kaiser db_save ./my_database.tar.bz
EOS

db_load_usage <<EOS
Shuts down the database docker container, *replaces* the database with the backup provided and brings the container up again.

The database will be restored from a tarball saved as `~/.kaiser/<ENV_NAME>/<current_github_branch_name>/<DB_BACKUP_FILENAME>.tar.bz`

Alternatively you can also load it from your current directory.

Usage: kaiser db_load DB_BACKUP_FILENAME
       kaiser db_load ./my_database.tar.bz
EOS

db_reset_usage <<EOS
Shuts down the database docker container, *replaces* the database with the default database image stored at `~/.kaiser/<ENV_NAME>/<current_github_branch_name>/.default.tar.bz` and brings the container up again.

Usage: kaiser db_reset
EOS

db_reset_hard_usage <<EOS
Shuts down the database docker container, deletes the docker volume on which the db was stored, deletes the default database image stored at `~/.kaiser/<ENV_NAME>/<current_github_branch_name>/.default.tar.bz`, rebuilds the docker volume and the default database image from scratch and then brings the container up again.

Usage: kaiser db_reset_hard
EOS

SUB_COMMANDS = %w[
  init
  deinit
  up
  down
  shutdown
  db_save
  db_load
  db_reset
  db_reset_hard
  logs
  attach
  login
  show
  set
].freeze

opts = Optimist.options do
  version "Kaiser v#{Kaiser::VERSION}"

  banner <<-BANNER
#{version}

Subcommands:
#{SUB_COMMANDS.join ' '}
  BANNER
  opt :verbose, "Show Kaiser's debug output", short: '-v'
  opt :quiet, 'Suppress all output', short: '-q'
end

commands = SUB_COMMANDS & ARGV
cmd = commands.first
ARGV.shift

Optimist.educate unless SUB_COMMANDS.include?(cmd)

out = Kaiser::Dotter.new
info_out = Kaiser::AfterDotter.new(dotter: out)

if opts[:quiet]
  out = File.open(File::NULL, 'w')
  info_out = File.open(File::NULL, 'w')
elsif opts[:verbose]
  out = $stderr
end

cli = Kaiser::KaiserCli.new(
  `pwd`.chomp,
  debug_output: out,
  info_output: info_out
)
cli.send(:"#{cmd}")

puts ''
