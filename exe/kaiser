#!/usr/bin/env ruby

require 'optimist'
require 'fileutils'
require 'yaml'
require 'json'
require 'pty'
require 'erb'

require 'kaiser'

main_usage <<EOS
Kaiser is a tool to make development a lot easier by defining how an application starts using a `Kaiserfile` in the source code's root directory.

### Prerequisites

Install docker on your system and make sure the current user have all the rights required to spin up docker containers.

### Usage

For typical usuage you'll want to do the following three commands.

```
kaiser init ENV_NAME
kaiser up
kaiser attach
```

This will boot up your application in docker and bind mount your local source directory so you can start doing development. Happy coding!

If any of these commands are giving you trouble, please run them with the `-v` flag set. They will show you what exactly is happening so you can debug.
EOS

init_usage <<EOS
Initializes a Kaiser environment and assigns ports for it in `~/.kaiser/.config.yml`. When running `kaiser up` later the directory `~/.kaiser/databases/<ENV_NAME>`  will get created.

Usage: kaiser init ENV_NAME
EOS

deinit_usage <<EOS
Removes the Kaiser environment from `~/.kaiser/.config.yml`. This however does not delete the `~/.kaiser/databases/<ENV_NAME>` directory.

Usage: kaiser init ENV_NAME
EOS

up_usage <<EOS
Boots up the application in docker as defined in the `Kaiserfile` in its source code. Often this will create two docker containers `<ENV_NAME>-db` and `<ENV_NAME>-app` running your database and application respectively.

Usage: kaiser up
EOS

down_usage <<EOS
Shuts down and *deletes* the containers that were started using `kaiser up`.

Usage: kaiser down
EOS

SUB_COMMANDS = %w[
  init
  deinit
  up
  down
  shutdown
  db_load
  db_save
  db_reset
  db_reset_hard
  logs
  attach
  login
  show
  set
].freeze

opts = Optimist.options do
  version "Kaiser v#{Kaiser::VERSION}"

  banner <<-BANNER
#{version}

Subcommands:
#{SUB_COMMANDS.join ' '}
  BANNER
  opt :verbose, "Show Kaiser's debug output", short: '-v'
  opt :quiet, 'Suppress all output', short: '-q'
end

commands = SUB_COMMANDS & ARGV
cmd = commands.first
ARGV.shift

Optimist.educate unless SUB_COMMANDS.include?(cmd)

out = Kaiser::Dotter.new
info_out = Kaiser::AfterDotter.new(dotter: out)

if opts[:quiet]
  out = File.open(File::NULL, 'w')
  info_out = File.open(File::NULL, 'w')
elsif opts[:verbose]
  out = $stderr
end

cli = Kaiser::KaiserCli.new(
  `pwd`.chomp,
  debug_output: out,
  info_output: info_out
)
cli.send(:"#{cmd}")

puts ''
