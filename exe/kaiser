#!/usr/bin/env ruby

require 'optimist'
require 'fileutils'
require 'yaml'
require 'json'
require 'pty'
require 'erb'

require 'kaiser'

main_usage <<EOS
Kaiser is a tool to make development a lot easier by defining how an application starts using a `Kaiserfile` in the source code's root directory.

### Prerequisites

Install docker on your system and make sure the current user have all the rights required to spin up docker containers.

### Usage

For typical usuage you'll want to do the following three commands.

```
kaiser init ENV_NAME
kaiser up
kaiser attach
```

This will boot up your application in docker and bind mount your local source directory so you can start doing development. Happy coding!
EOS

init_usage <<EOS
Initializes a Kaiser environment and assigns ports for it in `~/.kaiser/.config.yml`. When running `kaiser up` later the directory `~/.kaiser/databases/<ENV_NAME>`  will get created.

Usage: kaiser init ENV_NAME
EOS

deinit_usage <<EOS
Removes the Kaiser environment from `~/.kaiser/.config.yml`. This however does not delete the `~/.kaiser/databases/<ENV_NAME>` directory.

Usage: kaiser init ENV_NAME
EOS

SUB_COMMANDS = %w[
  init
  deinit
  up
  down
  shutdown
  db_load
  db_save
  db_reset
  db_reset_hard
  logs
  attach
  login
  show
  set
].freeze

opts = Optimist.options do
  version "Kaiser v#{Kaiser::VERSION}"

  banner <<-BANNER
#{version}

Subcommands:
#{SUB_COMMANDS.join ' '}
  BANNER
  opt :verbose, "Show Kaiser's debug output", short: '-v'
  opt :quiet, 'Suppress all output', short: '-q'
end

commands = SUB_COMMANDS & ARGV
cmd = commands.first
ARGV.shift

Optimist.educate unless SUB_COMMANDS.include?(cmd)

out = Kaiser::Dotter.new
info_out = Kaiser::AfterDotter.new(dotter: out)

if opts[:quiet]
  out = File.open(File::NULL, 'w')
  info_out = File.open(File::NULL, 'w')
elsif opts[:verbose]
  out = $stderr
end

cli = Kaiser::KaiserCli.new(
  `pwd`.chomp,
  debug_output: out,
  info_output: info_out
)
cli.send(:"#{cmd}")

puts ''
