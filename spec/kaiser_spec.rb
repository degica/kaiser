# frozen_string_literal: true

require 'open3'

RSpec.describe Kaiser do
  it 'has a version number' do
    expect(Kaiser::VERSION).not_to be nil
  end

  let(:cmd) do
    Open3.popen3("#{Dir.pwd}/exe/kaiser #{args}")
  end
  let(:cmd_stdout) { cmd[1].read }
  let(:cmd_stderr) { cmd[2].read }

  shared_examples 'full help' do
    it 'prints the full help message' do
      unwrapped_output = cmd_stdout.tr("\n", ' ')

      Kaiser::SUB_COMMANDS.keys.each do |name|
        expect(unwrapped_output).to include "- #{name}"
      end
    end
  end

  context 'without any subcommands' do
    let(:args) { '' }

    include_examples 'full help'
  end

  context 'without a non existing subcommand' do
    let(:args) { 'joske' }

    include_examples 'full help'
  end

  describe 'init' do
    let(:args) { 'init' }

    context 'with no Kaiserfile' do
      it 'Returns an error' do
        expect(cmd_stdout).to eq ''
        expect(cmd_stderr).to eq "Error: No Kaiserfile in current directory.\nTry --help for help.\n"
      end
    end
  end

  describe 'help messages' do
    Kaiser::SUB_COMMANDS.each do |name, klass|
      describe name do
        subject { klass.new }

        it 'has a help message defined' do
          expect(subject.methods).to include :usage
          expect(subject.usage).not_to be_nil
          expect(subject.usage).not_to be_empty
          # expect(subject.usage).to be_helpful
        end

        shared_examples 'single help' do
          it "prints the help message for just #{name} and nothing else" do
            # Remove the help arguments generated by Optimist as they won't be in the usage method
            # We remove each line after the first argument. We can't just check for lines that start
            # with '  -' because optimist might wrap them over multiple lines.
            lines = cmd_stdout.lines
            args_line = lines.index { |l| l =~ /^  -.+/ }
            unwrapped_output = lines[0, args_line].join

            # Remove all newlines because Optimist will wordwrap according to terminal size
            unwrapped_output.tr!("\n", ' ')
            unwrapped_usage = subject.usage.tr("\n", ' ')

            # Now we can check is it's the same as usage.
            expect(unwrapped_output).to eq unwrapped_usage
          end
        end

        context 'with -h before the subcommand' do
          let(:args) { "-h #{name}" }

          include_examples 'single help'
        end

        context 'with -h after the subcommand' do
          let(:args) { "#{name} -h" }

          include_examples 'single help'
        end
      end
    end
  end
end
